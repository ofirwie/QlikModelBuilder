/**
 * ScriptGenerator.ts - Generates Qlik Sense load scripts from ProjectSpec
 * Supports incremental loading patterns and QVD optimization
 */

import {
  ProjectSpec,
  TableSpec,
  IncrementalConfig
} from './types/ProjectSpec';

export interface ScriptOptions {
  qvdPath?: string;
  includeComments?: boolean;
  hebrewComments?: boolean;
  useVariables?: boolean;
}

const DEFAULT_OPTIONS: ScriptOptions = {
  qvdPath: 'lib://DataFiles/QVD/',
  includeComments: true,
  hebrewComments: true,
  useVariables: true
};

export class ScriptGenerator {
  private options: ScriptOptions;

  constructor(options: Partial<ScriptOptions> = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  /**
   * Generate complete Qlik script from ProjectSpec
   */
  generate(project: ProjectSpec): string {
    const sections: string[] = [];

    // Header
    sections.push(this.generateHeader(project));

    // Variables
    if (this.options.useVariables) {
      sections.push(this.generateVariables(project));
    }

    // Connection references
    sections.push(this.generateConnections(project));

    // Tables
    for (const table of project.tables) {
      const incrementalConfig = project.userSelections.incrementalConfig[table.name];
      if (incrementalConfig?.enabled) {
        sections.push(this.generateIncrementalLoad(table, incrementalConfig, project));
      } else {
        sections.push(this.generateFullLoad(table, project));
      }
    }

    // Footer
    sections.push(this.generateFooter());

    return sections.join('\n\n');
  }

  /**
   * Generate script header with metadata
   */
  private generateHeader(project: ProjectSpec): string {
    const lines: string[] = [];
    const comment = this.options.hebrewComments;

    lines.push('// ============================================');
    lines.push(`// ${comment ? 'נוצר אוטומטית על ידי' : 'Auto-generated by'} QlikModelBuilder`);
    lines.push(`// ${comment ? 'פרויקט' : 'Project'}: ${project.qlikConfig.appName || 'Unnamed'}`);
    lines.push(`// ${comment ? 'תאריך יצירה' : 'Generated'}: ${new Date().toISOString().split('T')[0]}`);
    lines.push(`// ${comment ? 'קובץ מקור' : 'Source'}: ${project.sourceFile || 'N/A'}`);
    lines.push(`// ${comment ? 'טבלאות' : 'Tables'}: ${project.tables.length}`);
    lines.push('// ============================================');

    return lines.join('\n');
  }

  /**
   * Generate variables section
   */
  private generateVariables(project: ProjectSpec): string {
    const lines: string[] = [];
    const comment = this.options.hebrewComments;

    lines.push(`// ${comment ? 'משתנים גלובליים' : 'Global Variables'}`);
    lines.push('// ============================================');
    lines.push('');

    // QVD path
    lines.push(`LET vQVDPath = '${this.options.qvdPath}';`);

    // Reload timestamp
    lines.push("LET vLastReload = Timestamp(Now(), 'YYYY-MM-DD hh:mm:ss');");

    // Source connection - use first connection from config
    const sourceConn = project.qlikConfig.connections.find(c => c.type === 'database');
    if (sourceConn) {
      lines.push(`LET vSourceConnection = 'lib://${sourceConn.name}/';`);
    }

    // File connection - use DataFiles connection
    const fileConn = project.qlikConfig.connections.find(c => c.type === 'datafiles');
    if (fileConn) {
      lines.push(`LET vFileConnection = 'lib://${fileConn.name}/';`);
    }

    return lines.join('\n');
  }

  /**
   * Generate connection references
   */
  private generateConnections(project: ProjectSpec): string {
    const lines: string[] = [];
    const comment = this.options.hebrewComments;

    if (project.qlikConfig.connections.length === 0) {
      return '';
    }

    lines.push(`// ${comment ? 'חיבורים' : 'Connections'}`);
    lines.push('// ============================================');

    for (const conn of project.qlikConfig.connections) {
      lines.push(`// ${conn.name} (${conn.type})`);
    }

    return lines.join('\n');
  }

  /**
   * Generate incremental load script for a table
   */
  private generateIncrementalLoad(
    table: TableSpec,
    config: IncrementalConfig,
    project: ProjectSpec
  ): string {
    const lines: string[] = [];
    const comment = this.options.hebrewComments;
    const qvdFile = `$(vQVDPath)${table.name}.qvd`;

    lines.push('// ============================================');
    lines.push(`// ${table.name} (${table.type} - Incremental: ${config.strategy})`);
    lines.push('// ============================================');
    lines.push('');

    // Generate field list
    const fieldList = this.generateFieldList(table);
    const sourceLib = this.getSourceLib(project);

    switch (config.strategy) {
      case 'insert_only':
        lines.push(this.generateInsertOnlyScript(table, config, fieldList, sourceLib, qvdFile));
        break;
      case 'insert_update':
        lines.push(this.generateInsertUpdateScript(table, config, fieldList, sourceLib, qvdFile));
        break;
      case 'time_window':
        lines.push(this.generateTimeWindowScript(table, config, fieldList, sourceLib, qvdFile));
        break;
      default:
        lines.push(this.generateFullLoadScript(table, fieldList, sourceLib, qvdFile));
    }

    return lines.join('\n');
  }

  /**
   * Generate Insert-Only incremental pattern
   * Used for append-only data (logs, events, transactions)
   */
  private generateInsertOnlyScript(
    table: TableSpec,
    config: IncrementalConfig,
    fieldList: string,
    sourceLib: string,
    qvdFile: string
  ): string {
    const keyField = table.keyField || table.fields[0]?.name || 'ID';

    return `
LET vQVDFile = '${qvdFile}';

IF NOT IsNull(FileSize('$(vQVDFile)')) THEN
  // Load existing data from QVD
  [${table.name}]:
  LOAD ${fieldList}
  FROM [$(vQVDFile)] (qvd);

  // Get max key for incremental
  LET vMaxKey = Peek('${keyField}', -1, '${table.name}');

  // Load new records only
  Concatenate([${table.name}])
  LOAD ${fieldList}
  FROM [${sourceLib}${table.name}]
  WHERE ${keyField} > $(vMaxKey);
ELSE
  // First load: Full extract
  [${table.name}]:
  LOAD ${fieldList}
  FROM [${sourceLib}${table.name}];
END IF

// Store updated data
STORE [${table.name}] INTO [$(vQVDFile)] (qvd);
`.trim();
  }

  /**
   * Generate Insert-Update incremental pattern
   * Used for data that can be updated (master data, slowly changing dimensions)
   */
  private generateInsertUpdateScript(
    table: TableSpec,
    config: IncrementalConfig,
    fieldList: string,
    sourceLib: string,
    qvdFile: string
  ): string {
    const keyField = table.keyField || table.fields[0]?.name || 'ID';
    const dateField = config.field || 'ModifiedDate';

    return `
LET vQVDFile = '${qvdFile}';

IF NOT IsNull(FileSize('$(vQVDFile)')) THEN
  // Get last load timestamp from QVD
  TempLastLoad:
  LOAD Max(${dateField}) as MaxDate
  FROM [$(vQVDFile)] (qvd);

  LET vLastUpdate = Peek('MaxDate', 0, 'TempLastLoad');
  DROP TABLE TempLastLoad;

  // Load changed records from source
  [${table.name}_New]:
  LOAD ${fieldList}
  FROM [${sourceLib}${table.name}]
  WHERE ${dateField} >= '$(vLastUpdate)';

  // Load existing records NOT in the updated set
  [${table.name}]:
  LOAD ${fieldList}
  FROM [$(vQVDFile)] (qvd)
  WHERE NOT EXISTS(${keyField});

  // Concatenate updated records
  Concatenate([${table.name}])
  LOAD ${fieldList}
  RESIDENT [${table.name}_New];

  DROP TABLE [${table.name}_New];
ELSE
  // First load: Full extract
  [${table.name}]:
  LOAD ${fieldList}
  FROM [${sourceLib}${table.name}];
END IF

// Store updated data
STORE [${table.name}] INTO [$(vQVDFile)] (qvd);
`.trim();
  }

  /**
   * Generate Time-Window incremental pattern
   * Used for large fact tables with time-based partitioning
   */
  private generateTimeWindowScript(
    table: TableSpec,
    config: IncrementalConfig,
    fieldList: string,
    sourceLib: string,
    qvdFile: string
  ): string {
    const dateField = config.field || 'Date';

    return `
LET vQVDFile = '${qvdFile}';
LET vWindowDays = 30; // Reload window in days

IF NOT IsNull(FileSize('$(vQVDFile)')) THEN
  LET vCutoffDate = Date(Today() - $(vWindowDays), 'YYYY-MM-DD');

  // Load historical data (before window)
  [${table.name}]:
  LOAD ${fieldList}
  FROM [$(vQVDFile)] (qvd)
  WHERE ${dateField} < '$(vCutoffDate)';

  // Reload data within window from source
  Concatenate([${table.name}])
  LOAD ${fieldList}
  FROM [${sourceLib}${table.name}]
  WHERE ${dateField} >= '$(vCutoffDate)';
ELSE
  // First load: Full extract
  [${table.name}]:
  LOAD ${fieldList}
  FROM [${sourceLib}${table.name}];
END IF

// Store updated data
STORE [${table.name}] INTO [$(vQVDFile)] (qvd);
`.trim();
  }

  /**
   * Generate full load script for a table
   */
  private generateFullLoad(table: TableSpec, project: ProjectSpec): string {
    const lines: string[] = [];
    const fieldList = this.generateFieldList(table);
    const sourceLib = this.getSourceLib(project);
    const qvdFile = `$(vQVDPath)${table.name}.qvd`;

    lines.push('// ============================================');
    lines.push(`// ${table.name} (${table.type} - Full Reload)`);
    lines.push('// ============================================');
    lines.push('');
    lines.push(this.generateFullLoadScript(table, fieldList, sourceLib, qvdFile));

    return lines.join('\n');
  }

  /**
   * Generate simple full load script
   */
  private generateFullLoadScript(
    table: TableSpec,
    fieldList: string,
    sourceLib: string,
    qvdFile: string
  ): string {
    return `
[${table.name}]:
LOAD ${fieldList}
FROM [${sourceLib}${table.name}];

STORE [${table.name}] INTO [${qvdFile}] (qvd);
`.trim();
  }

  /**
   * Generate field list for LOAD statement
   */
  private generateFieldList(table: TableSpec): string {
    const includedFields = table.fields.filter(f => f.include);

    if (includedFields.length === 0) {
      return '*';
    }

    // Generate field expressions with optional renaming
    const fieldExprs = includedFields.map(field => {
      if (field.rename && field.rename !== field.name) {
        return `[${field.name}] AS [${field.rename}]`;
      }
      return `[${field.name}]`;
    });

    // Format nicely with indentation if more than 3 fields
    if (fieldExprs.length > 3) {
      return '\n    ' + fieldExprs.join(',\n    ');
    }

    return fieldExprs.join(', ');
  }

  /**
   * Get source library path
   */
  private getSourceLib(project: ProjectSpec): string {
    const dbConn = project.qlikConfig.connections.find(c => c.type === 'database');
    if (dbConn) {
      return `lib://${dbConn.name}/`;
    }

    const fileConn = project.qlikConfig.connections.find(c => c.type === 'datafiles');
    if (fileConn) {
      return `lib://${fileConn.name}/`;
    }

    return 'lib://DataFiles/';
  }

  /**
   * Generate script footer
   */
  private generateFooter(): string {
    const comment = this.options.hebrewComments;

    return `
// ============================================
// ${comment ? 'סיום טעינה' : 'End of Load Script'}
// ============================================
LET vScriptEndTime = Now();
LET vScriptDuration = Interval($(vScriptEndTime) - $(vLastReload), 'hh:mm:ss');

// ${comment ? 'ניקוי משתנים זמניים' : 'Cleanup temporary variables'}
// LET vMaxKey = Null();
// LET vLastUpdate = Null();
// LET vCutoffDate = Null();
`.trim();
  }

  /**
   * Validate generated script (basic syntax check)
   */
  validateScript(script: string): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for balanced parentheses
    const openParens = (script.match(/\(/g) || []).length;
    const closeParens = (script.match(/\)/g) || []).length;
    if (openParens !== closeParens) {
      errors.push(`Unbalanced parentheses: ${openParens} open, ${closeParens} close`);
    }

    // Check for balanced brackets
    const openBrackets = (script.match(/\[/g) || []).length;
    const closeBrackets = (script.match(/\]/g) || []).length;
    if (openBrackets !== closeBrackets) {
      errors.push(`Unbalanced brackets: ${openBrackets} open, ${closeBrackets} close`);
    }

    // Check for unclosed IF statements (must be at start of line or after whitespace)
    // Match "IF " at line start, not inside words like "DataFiles"
    const ifCount = (script.match(/^IF\s|[\n\r]IF\s/gi) || []).length;
    const endIfCount = (script.match(/^END\s+IF|[\n\r]END\s+IF/gi) || []).length;
    if (ifCount !== endIfCount) {
      errors.push(`Unbalanced IF/END IF: ${ifCount} IF, ${endIfCount} END IF`);
    }

    // LET validation removed - the pattern was too aggressive
    // Qlik allows multi-line LET statements

    return {
      valid: errors.length === 0,
      errors
    };
  }
}
